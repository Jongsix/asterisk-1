#------------------------------------------------------------------------------
#
#  WARNING !
#
#  This is a generated file. DO NOT EDIT THIS FILE! Your changes will
#  be lost the next time this file is regenerated.
#
#  This file was generated using ctiapps/asterisk crystal shard from the
#  Asterisk PBX version 16.5.0.
#
#------------------------------------------------------------------------------

module Asterisk
  class ARI
    class Channels < Resource
      # List all active channels in Asterisk.
      def list : Array(Channels::Channel)
        client.get "/channels"
      end

      # Create a new channel (originate).
      #
      # Arguments:
      # - `endpoint` - endpoint to call.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: endpoint,
      #
      # - `extension` - the extension to dial after the endpoint answers. Mutually exclusive with 'app'.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: extension,
      #
      # - `context` - the context to dial after the endpoint answers. If omitted, uses 'default'. Mutually exclusive with 'app'.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: context,
      #
      # - `priority` - the priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with 'app'.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: priority,
      #
      # - `label` - the label to dial after the endpoint answers. Will supersede 'priority' if provided. Mutually exclusive with 'app'.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: label,
      #
      # - `app` - the application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: app,
      #
      # - `app_args` - the application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: appArgs,
      #
      # - `caller_id` - callerID to use when dialing the endpoint or extension.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: callerId,
      #
      # - `timeout` - timeout (in seconds) before giving up dialing, or -1 for no timeout.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: timeout,
      #
      # - `variables` - the "variables" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { "endpoint": "SIP/Alice", "variables": { "CALLERID(name)": "Alice" } }.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: body,
      #   - param name: variables,
      #
      # - `channel_id` - the unique id to assign the channel on creation.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: channelId,
      #
      # - `other_channel_id` - the unique id to assign the second channel when using local channels.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: otherChannelId,
      #
      # - `originator` - the unique id of the channel which is originating this one.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: originator,
      #
      # - `formats` - the format name capability list to use if originator is not specified. Ex. "ulaw,slin16".  Format names can be found with "core show codecs".
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: formats,
      #   - endpoint (post): /channels
      #
      # Error responses:
      # - 400 - Invalid parameters for originating a channel.
      # - 409 - Channel with given unique ID already exists.
      def originate(endpoint : String, extension : String? = nil, context : String? = nil, priority : Int64? = nil, label : String? = nil, app : String? = nil, app_args : String? = nil, caller_id : String? = nil, timeout : Int32? = 30, variables : Hash(String, String | Bool | Int32 | Float32)? = nil, channel_id : String? = nil, other_channel_id : String? = nil, originator : String? = nil, formats : String? = nil) : Channels::Channel
        params = HTTP::Params.encode({"endpoint" => endpoint})

        # Optional parameters
        params += "&" + HTTP::Params.encode({"extension" => extension}) if extension
        params += "&" + HTTP::Params.encode({"context" => context}) if context
        params += "&" + HTTP::Params.encode({"priority" => priority}) if priority
        params += "&" + HTTP::Params.encode({"label" => label}) if label
        params += "&" + HTTP::Params.encode({"app" => app}) if app
        params += "&" + HTTP::Params.encode({"appArgs" => app_args}) if app_args
        params += "&" + HTTP::Params.encode({"callerId" => caller_id}) if caller_id
        params += "&" + HTTP::Params.encode({"timeout" => timeout}) if timeout
        params += "&" + HTTP::Params.encode({"channelId" => channel_id}) if channel_id
        params += "&" + HTTP::Params.encode({"otherChannelId" => other_channel_id}) if other_channel_id
        params += "&" + HTTP::Params.encode({"originator" => originator}) if originator
        params += "&" + HTTP::Params.encode({"formats" => formats}) if formats

        response = client.post "/channels?" + params,
          body: variables.to_json
      end

      # Create channel.
      #
      # Arguments:
      # - `endpoint` - endpoint for channel communication.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: endpoint,
      #
      # - `app` - stasis Application to place channel into.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: app,
      #
      # - `app_args` - the application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: appArgs,
      #
      # - `channel_id` - the unique id to assign the channel on creation.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: channelId,
      #
      # - `other_channel_id` - the unique id to assign the second channel when using local channels.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: otherChannelId,
      #
      # - `originator` - unique ID of the calling channel.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: originator,
      #
      # - `formats` - the format name capability list to use if originator is not specified. Ex. "ulaw,slin16".  Format names can be found with "core show codecs".
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: formats,
      #   - endpoint (post): /channels/create
      #
      # Error responses:
      # - 409 - Channel with given unique ID already exists.
      def create(endpoint : String, app : String, app_args : String? = nil, channel_id : String? = nil, other_channel_id : String? = nil, originator : String? = nil, formats : String? = nil) : Channels::Channel
        params = HTTP::Params.encode({"endpoint" => endpoint, "app" => app})

        # Optional parameters
        params += "&" + HTTP::Params.encode({"appArgs" => app_args}) if app_args
        params += "&" + HTTP::Params.encode({"channelId" => channel_id}) if channel_id
        params += "&" + HTTP::Params.encode({"otherChannelId" => other_channel_id}) if other_channel_id
        params += "&" + HTTP::Params.encode({"originator" => originator}) if originator
        params += "&" + HTTP::Params.encode({"formats" => formats}) if formats

        response = client.post "/channels/create?" + params
      end

      # Channel details.
      #
      # Arguments:
      # - `channel_id` - channel's id.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: path,
      #   - param name: channelId,
      #   - endpoint (get): /channels/{channelId}
      #
      # Error responses:
      # - 404 - Channel not found
      def get(channel_id : String) : Channels::Channel
        response = client.get "/channels/#{channel_id}"
      end

      # Create a new channel (originate with id).
      #
      # Arguments:
      # - `channel_id` - the unique id to assign the channel on creation.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: path,
      #   - param name: channelId,
      #
      # - `endpoint` - endpoint to call.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: endpoint,
      #
      # - `extension` - the extension to dial after the endpoint answers. Mutually exclusive with 'app'.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: extension,
      #
      # - `context` - the context to dial after the endpoint answers. If omitted, uses 'default'. Mutually exclusive with 'app'.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: context,
      #
      # - `priority` - the priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with 'app'.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: priority,
      #
      # - `label` - the label to dial after the endpoint answers. Will supersede 'priority' if provided. Mutually exclusive with 'app'.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: label,
      #
      # - `app` - the application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: app,
      #
      # - `app_args` - the application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: appArgs,
      #
      # - `caller_id` - callerID to use when dialing the endpoint or extension.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: callerId,
      #
      # - `timeout` - timeout (in seconds) before giving up dialing, or -1 for no timeout.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: timeout,
      #
      # - `variables` - the "variables" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { "endpoint": "SIP/Alice", "variables": { "CALLERID(name)": "Alice" } }.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: body,
      #   - param name: variables,
      #
      # - `other_channel_id` - the unique id to assign the second channel when using local channels.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: otherChannelId,
      #
      # - `originator` - the unique id of the channel which is originating this one.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: originator,
      #
      # - `formats` - the format name capability list to use if originator is not specified. Ex. "ulaw,slin16".  Format names can be found with "core show codecs".
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: formats,
      #   - endpoint (post): /channels/{channelId}
      #
      # Error responses:
      # - 400 - Invalid parameters for originating a channel.
      # - 409 - Channel with given unique ID already exists.
      def originate_with_id(channel_id : String, endpoint : String, extension : String? = nil, context : String? = nil, priority : Int64? = nil, label : String? = nil, app : String? = nil, app_args : String? = nil, caller_id : String? = nil, timeout : Int32? = 30, variables : Hash(String, String | Bool | Int32 | Float32)? = nil, other_channel_id : String? = nil, originator : String? = nil, formats : String? = nil) : Channels::Channel
        params = HTTP::Params.encode({"endpoint" => endpoint})

        # Optional parameters
        params += "&" + HTTP::Params.encode({"extension" => extension}) if extension
        params += "&" + HTTP::Params.encode({"context" => context}) if context
        params += "&" + HTTP::Params.encode({"priority" => priority}) if priority
        params += "&" + HTTP::Params.encode({"label" => label}) if label
        params += "&" + HTTP::Params.encode({"app" => app}) if app
        params += "&" + HTTP::Params.encode({"appArgs" => app_args}) if app_args
        params += "&" + HTTP::Params.encode({"callerId" => caller_id}) if caller_id
        params += "&" + HTTP::Params.encode({"timeout" => timeout}) if timeout
        params += "&" + HTTP::Params.encode({"otherChannelId" => other_channel_id}) if other_channel_id
        params += "&" + HTTP::Params.encode({"originator" => originator}) if originator
        params += "&" + HTTP::Params.encode({"formats" => formats}) if formats

        response = client.post "/channels/#{channel_id}?" + params,
          body: variables.to_json
      end

      # Delete (i.e. hangup) a channel.
      #
      # Arguments:
      # - `channel_id` - channel's id.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: path,
      #   - param name: channelId,
      #
      # - `reason` - reason for hanging up the channel.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: reason,
      #   - endpoint (delete): /channels/{channelId}
      #
      # Error responses:
      # - 400 - Invalid reason for hangup provided
      # - 404 - Channel not found
      def hangup(channel_id : String, reason : String? = nil)
        # Optional parameters
        params = HTTP::Params.encode({} of String => String)
        params += "&" + HTTP::Params.encode({"reason" => reason}) if reason

        response = client.delete "/channels/#{channel_id}?" + params
      end

      # Exit application; continue execution in the dialplan.
      #
      # Arguments:
      # - `channel_id` - channel's id.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: path,
      #   - param name: channelId,
      #
      # - `context` - the context to continue to.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: context,
      #
      # - `extension` - the extension to continue to.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: extension,
      #
      # - `priority` - the priority to continue to.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: priority,
      #
      # - `label` - the label to continue to - will supersede 'priority' if both are provided.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: label,
      #   - endpoint (post): /channels/{channelId}/continue
      #
      # Error responses:
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      # - 412 - Channel in invalid state
      def continue_in_dialplan(channel_id : String, context : String? = nil, extension : String? = nil, priority : Int32? = nil, label : String? = nil)
        # Optional parameters
        params = HTTP::Params.encode({} of String => String)
        params += "&" + HTTP::Params.encode({"context" => context}) if context
        params += "&" + HTTP::Params.encode({"extension" => extension}) if extension
        params += "&" + HTTP::Params.encode({"priority" => priority}) if priority
        params += "&" + HTTP::Params.encode({"label" => label}) if label

        response = client.post "/channels/#{channel_id}/continue?" + params
      end

      # Move the channel from one Stasis application to another.
      #
      # Arguments:
      # - `channel_id` - channel's id.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: path,
      #   - param name: channelId,
      #
      # - `app` - the channel will be passed to this Stasis application.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: app,
      #
      # - `app_args` - the application arguments to pass to the Stasis application provided by 'app'.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: appArgs,
      #   - endpoint (post): /channels/{channelId}/move
      #
      # Error responses:
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      def move(channel_id : String, app : String, app_args : String? = nil)
        params = HTTP::Params.encode({"app" => app})

        # Optional parameters
        params += "&" + HTTP::Params.encode({"appArgs" => app_args}) if app_args

        response = client.post "/channels/#{channel_id}/move?" + params
      end

      # Redirect the channel to a different location.
      #
      # Arguments:
      # - `channel_id` - channel's id.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: path,
      #   - param name: channelId,
      #
      # - `endpoint` - the endpoint to redirect the channel to.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: endpoint,
      #   - endpoint (post): /channels/{channelId}/redirect
      #
      # Error responses:
      # - 400 - Endpoint parameter not provided
      # - 404 - Channel or endpoint not found
      # - 409 - Channel not in a Stasis application
      # - 422 - Endpoint is not the same type as the channel
      # - 412 - Channel in invalid state
      def redirect(channel_id : String, endpoint : String)
        params = HTTP::Params.encode({"endpoint" => endpoint})
        response = client.post "/channels/#{channel_id}/redirect?" + params
      end

      # Answer a channel.
      #
      # Arguments:
      # - `channel_id` - channel's id.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: path,
      #   - param name: channelId,
      #   - endpoint (post): /channels/{channelId}/answer
      #
      # Error responses:
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      # - 412 - Channel in invalid state
      def answer(channel_id : String)
        response = client.post "channels/#{channel_id}/answer"
        pp response
        response
      end

      # Indicate ringing to a channel.
      #
      # Arguments:
      # - `channel_id` - channel's id.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: path,
      #   - param name: channelId,
      #   - endpoint (post): /channels/{channelId}/ring
      #
      # Error responses:
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      # - 412 - Channel in invalid state
      def ring(channel_id : String)
        response = client.post "/channels/#{channel_id}/ring"
      end

      # Stop ringing indication on a channel if locally generated.
      #
      # Arguments:
      # - `channel_id` - channel's id.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: path,
      #   - param name: channelId,
      #   - endpoint (delete): /channels/{channelId}/ring
      #
      # Error responses:
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      # - 412 - Channel in invalid state
      def ring_stop(channel_id : String)
        response = client.delete "/channels/#{channel_id}/ring"
      end

      # Send provided DTMF to a given channel.
      #
      # Arguments:
      # - `channel_id` - channel's id.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: path,
      #   - param name: channelId,
      #
      # - `dtmf` - dTMF To send.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: dtmf,
      #
      # - `before` - amount of time to wait before DTMF digits (specified in milliseconds) start.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: before,
      #
      # - `between` - amount of time in between DTMF digits (specified in milliseconds).
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: between,
      #
      # - `duration` - length of each DTMF digit (specified in milliseconds).
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: duration,
      #
      # - `after` - amount of time to wait after DTMF digits (specified in milliseconds) end.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: after,
      #   - endpoint (post): /channels/{channelId}/dtmf
      #
      # Error responses:
      # - 400 - DTMF is required
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      # - 412 - Channel in invalid state
      def send_dtmf(channel_id : String, dtmf : String? = nil, before : Int32? = 0, between : Int32? = 100, duration : Int32? = 100, after : Int32? = 0)
        # Optional parameters
        params = HTTP::Params.encode({} of String => String)
        params += "&" + HTTP::Params.encode({"dtmf" => dtmf}) if dtmf
        params += "&" + HTTP::Params.encode({"before" => before}) if before
        params += "&" + HTTP::Params.encode({"between" => between}) if between
        params += "&" + HTTP::Params.encode({"duration" => duration}) if duration
        params += "&" + HTTP::Params.encode({"after" => after}) if after

        response = client.post "/channels/#{channel_id}/dtmf?" + params
      end

      # Mute a channel.
      #
      # Arguments:
      # - `channel_id` - channel's id.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: path,
      #   - param name: channelId,
      #
      # - `direction` - direction in which to mute audio.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: direction,
      #   - endpoint (post): /channels/{channelId}/mute
      #
      # Error responses:
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      # - 412 - Channel in invalid state
      def mute(channel_id : String, direction : String? = both)
        # Optional parameters
        params = HTTP::Params.encode({} of String => String)
        params += "&" + HTTP::Params.encode({"direction" => direction}) if direction

        response = client.post "/channels/#{channel_id}/mute?" + params
      end

      # Unmute a channel.
      #
      # Arguments:
      # - `channel_id` - channel's id.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: path,
      #   - param name: channelId,
      #
      # - `direction` - direction in which to unmute audio.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: direction,
      #   - endpoint (delete): /channels/{channelId}/mute
      #
      # Error responses:
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      # - 412 - Channel in invalid state
      def unmute(channel_id : String, direction : String? = both)
        # Optional parameters
        params = HTTP::Params.encode({} of String => String)
        params += "&" + HTTP::Params.encode({"direction" => direction}) if direction

        response = client.delete "/channels/#{channel_id}/mute?" + params
      end

      # Hold a channel.
      #
      # Arguments:
      # - `channel_id` - channel's id.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: path,
      #   - param name: channelId,
      #   - endpoint (post): /channels/{channelId}/hold
      #
      # Error responses:
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      # - 412 - Channel in invalid state
      def hold(channel_id : String)
        response = client.post "/channels/#{channel_id}/hold"
      end

      # Remove a channel from hold.
      #
      # Arguments:
      # - `channel_id` - channel's id.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: path,
      #   - param name: channelId,
      #   - endpoint (delete): /channels/{channelId}/hold
      #
      # Error responses:
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      # - 412 - Channel in invalid state
      def unhold(channel_id : String)
        response = client.delete "/channels/#{channel_id}/hold"
      end

      # Play music on hold to a channel.
      #
      # Arguments:
      # - `channel_id` - channel's id.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: path,
      #   - param name: channelId,
      #
      # - `moh_class` - music on hold class to use.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: mohClass,
      #   - endpoint (post): /channels/{channelId}/moh
      #
      # Error responses:
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      # - 412 - Channel in invalid state
      def start_moh(channel_id : String, moh_class : String? = nil)
        # Optional parameters
        params = HTTP::Params.encode({} of String => String)
        params += "&" + HTTP::Params.encode({"mohClass" => moh_class}) if moh_class

        response = client.post "/channels/#{channel_id}/moh?" + params
      end

      # Stop playing music on hold to a channel.
      #
      # Arguments:
      # - `channel_id` - channel's id.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: path,
      #   - param name: channelId,
      #   - endpoint (delete): /channels/{channelId}/moh
      #
      # Error responses:
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      # - 412 - Channel in invalid state
      def stop_moh(channel_id : String)
        response = client.delete "/channels/#{channel_id}/moh"
      end

      # Play silence to a channel.
      #
      # Arguments:
      # - `channel_id` - channel's id.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: path,
      #   - param name: channelId,
      #   - endpoint (post): /channels/{channelId}/silence
      #
      # Error responses:
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      # - 412 - Channel in invalid state
      def start_silence(channel_id : String)
        response = client.post "/channels/#{channel_id}/silence"
      end

      # Stop playing silence to a channel.
      #
      # Arguments:
      # - `channel_id` - channel's id.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: path,
      #   - param name: channelId,
      #   - endpoint (delete): /channels/{channelId}/silence
      #
      # Error responses:
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      # - 412 - Channel in invalid state
      def stop_silence(channel_id : String)
        response = client.delete "/channels/#{channel_id}/silence"
      end

      # Start playback of media.
      #
      # Arguments:
      # - `channel_id` - channel's id.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: path,
      #   - param name: channelId,
      #
      # - `media` - media URIs to play.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): true,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: media,
      #
      # - `lang` - for sounds, selects language for sound.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: lang,
      #
      # - `offsetms` - number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: offsetms,
      #
      # - `skipms` - number of milliseconds to skip for forward/reverse operations.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: skipms,
      #
      # - `playback_id` - playback ID.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: playbackId,
      #   - endpoint (post): /channels/{channelId}/play
      #
      # Error responses:
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      # - 412 - Channel in invalid state
      def play(channel_id : String, media : String, lang : String? = nil, offsetms : Int32? = nil, skipms : Int32? = 3000, playback_id : String? = nil) : Playbacks::Playback
        params = HTTP::Params.encode({"media" => media})

        # Optional parameters
        params += "&" + HTTP::Params.encode({"lang" => lang}) if lang
        params += "&" + HTTP::Params.encode({"offsetms" => offsetms}) if offsetms
        params += "&" + HTTP::Params.encode({"skipms" => skipms}) if skipms
        params += "&" + HTTP::Params.encode({"playbackId" => playback_id}) if playback_id

        response = client.post "/channels/#{channel_id}/play?" + params
      end

      # Start playback of media and specify the playbackId.
      #
      # Arguments:
      # - `channel_id` - channel's id.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: path,
      #   - param name: channelId,
      #
      # - `playback_id` - playback ID.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: path,
      #   - param name: playbackId,
      #
      # - `media` - media URIs to play.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): true,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: media,
      #
      # - `lang` - for sounds, selects language for sound.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: lang,
      #
      # - `offsetms` - number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: offsetms,
      #
      # - `skipms` - number of milliseconds to skip for forward/reverse operations.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: skipms,
      #   - endpoint (post): /channels/{channelId}/play/{playbackId}
      #
      # Error responses:
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      # - 412 - Channel in invalid state
      def play_with_id(channel_id : String, playback_id : String, media : String, lang : String? = nil, offsetms : Int32? = nil, skipms : Int32? = 3000) : Playbacks::Playback
        params = HTTP::Params.encode({"media" => media})

        # Optional parameters
        params += "&" + HTTP::Params.encode({"lang" => lang}) if lang
        params += "&" + HTTP::Params.encode({"offsetms" => offsetms}) if offsetms
        params += "&" + HTTP::Params.encode({"skipms" => skipms}) if skipms

        response = client.post "/channels/#{channel_id}/play/#{playback_id}?" + params
      end

      # Start a recording.
      #
      # Arguments:
      # - `channel_id` - channel's id.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: path,
      #   - param name: channelId,
      #
      # - `name` - recording's filename.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: name,
      #
      # - `format` - format to encode audio in.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: format,
      #
      # - `max_duration_seconds` - maximum duration of the recording, in seconds. 0 for no limit.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: maxDurationSeconds,
      #
      # - `max_silence_seconds` - maximum duration of silence, in seconds. 0 for no limit.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: maxSilenceSeconds,
      #
      # - `if_exists` - action to take if a recording with the same name already exists.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: ifExists,
      #
      # - `beep` - play beep when recording begins.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: beep,
      #
      # - `terminate_on` - dTMF input to terminate recording.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: terminateOn,
      #   - endpoint (post): /channels/{channelId}/record
      #
      # Error responses:
      # - 400 - Invalid parameters
      # - 404 - Channel not found
      # - 409 - Channel is not in a Stasis application; the channel is currently bridged with other hcannels; A recording with the same name already exists on the system and can not be overwritten because it is in progress or ifExists=fail
      # - 422 - The format specified is unknown on this system
      def record(channel_id : String, name : String, format : String, max_duration_seconds : Int32? = 0, max_silence_seconds : Int32? = 0, if_exists : String? = fail, beep : Bool? = false, terminate_on : String? = none) : Recordings::LiveRecording
        params = HTTP::Params.encode({"name" => name, "format" => format})

        # Optional parameters
        params += "&" + HTTP::Params.encode({"maxDurationSeconds" => max_duration_seconds}) if max_duration_seconds
        params += "&" + HTTP::Params.encode({"maxSilenceSeconds" => max_silence_seconds}) if max_silence_seconds
        params += "&" + HTTP::Params.encode({"ifExists" => if_exists}) if if_exists
        params += "&" + HTTP::Params.encode({"beep" => beep}) if beep
        params += "&" + HTTP::Params.encode({"terminateOn" => terminate_on}) if terminate_on

        response = client.post "/channels/#{channel_id}/record?" + params
      end

      # Get the value of a channel variable or function.
      #
      # Arguments:
      # - `channel_id` - channel's id.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: path,
      #   - param name: channelId,
      #
      # - `variable` - the channel variable or function to get.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: variable,
      #   - endpoint (get): /channels/{channelId}/variable
      #
      # Error responses:
      # - 400 - Missing variable parameter.
      # - 404 - Channel or variable not found
      # - 409 - Channel not in a Stasis application
      def get_channel_var(channel_id : String, variable : String) : Asterisk::Variable
        params = HTTP::Params.encode({"variable" => variable})
        response = client.get "/channels/#{channel_id}/variable?" + params
      end

      # Set the value of a channel variable or function.
      #
      # Arguments:
      # - `channel_id` - channel's id.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: path,
      #   - param name: channelId,
      #
      # - `variable` - the channel variable or function to set.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: variable,
      #
      # - `value` - the value to set the variable to.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: value,
      #   - endpoint (post): /channels/{channelId}/variable
      #
      # Error responses:
      # - 400 - Missing variable parameter.
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      def set_channel_var(channel_id : String, variable : String, value : String? = nil)
        params = HTTP::Params.encode({"variable" => variable})

        # Optional parameters
        params += "&" + HTTP::Params.encode({"value" => value}) if value

        response = client.post "/channels/#{channel_id}/variable?" + params
      end

      # Start snooping.
      #
      # Arguments:
      # - `channel_id` - channel's id.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: path,
      #   - param name: channelId,
      #
      # - `app` - application the snooping channel is placed into.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: app,
      #
      # - `spy` - direction of audio to spy on.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: spy,
      #
      # - `whisper` - direction of audio to whisper into.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: whisper,
      #
      # - `app_args` - the application arguments to pass to the Stasis application.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: appArgs,
      #
      # - `snoop_id` - unique ID to assign to snooping channel.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: snoopId,
      #   - endpoint (post): /channels/{channelId}/snoop
      #
      # Error responses:
      # - 400 - Invalid parameters
      # - 404 - Channel not found
      def snoop_channel(channel_id : String, app : String, spy : String? = none, whisper : String? = none, app_args : String? = nil, snoop_id : String? = nil) : Channels::Channel
        params = HTTP::Params.encode({"app" => app})

        # Optional parameters
        params += "&" + HTTP::Params.encode({"spy" => spy}) if spy
        params += "&" + HTTP::Params.encode({"whisper" => whisper}) if whisper
        params += "&" + HTTP::Params.encode({"appArgs" => app_args}) if app_args
        params += "&" + HTTP::Params.encode({"snoopId" => snoop_id}) if snoop_id

        response = client.post "/channels/#{channel_id}/snoop?" + params
      end

      # Start snooping.
      #
      # Arguments:
      # - `channel_id` - channel's id.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: path,
      #   - param name: channelId,
      #
      # - `snoop_id` - unique ID to assign to snooping channel.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: path,
      #   - param name: snoopId,
      #
      # - `app` - application the snooping channel is placed into.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: app,
      #
      # - `spy` - direction of audio to spy on.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: spy,
      #
      # - `whisper` - direction of audio to whisper into.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: whisper,
      #
      # - `app_args` - the application arguments to pass to the Stasis application.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: appArgs,
      #   - endpoint (post): /channels/{channelId}/snoop/{snoopId}
      #
      # Error responses:
      # - 400 - Invalid parameters
      # - 404 - Channel not found
      def snoop_channel_with_id(channel_id : String, snoop_id : String, app : String, spy : String? = none, whisper : String? = none, app_args : String? = nil) : Channels::Channel
        params = HTTP::Params.encode({"app" => app})

        # Optional parameters
        params += "&" + HTTP::Params.encode({"spy" => spy}) if spy
        params += "&" + HTTP::Params.encode({"whisper" => whisper}) if whisper
        params += "&" + HTTP::Params.encode({"appArgs" => app_args}) if app_args

        response = client.post "/channels/#{channel_id}/snoop/#{snoop_id}?" + params
      end

      # Dial a created channel.
      #
      # Arguments:
      # - `channel_id` - channel's id.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: path,
      #   - param name: channelId,
      #
      # - `caller` - channel ID of caller.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: caller,
      #
      # - `timeout` - dial timeout.
      #   - Required: false,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: query,
      #   - param name: timeout,
      #   - endpoint (post): /channels/{channelId}/dial
      #
      # Error responses:
      # - 404 - Channel cannot be found.
      # - 409 - Channel cannot be dialed.
      def dial(channel_id : String, caller : String? = nil, timeout : Int32? = 0)
        # Optional parameters
        params = HTTP::Params.encode({} of String => String)
        params += "&" + HTTP::Params.encode({"caller" => caller}) if caller
        params += "&" + HTTP::Params.encode({"timeout" => timeout}) if timeout

        response = client.post "/channels/#{channel_id}/dial?" + params
      end

      # RTP stats on a channel.
      #
      # Arguments:
      # - `channel_id` - channel's id.
      #   - Required: true,
      #   - Allow multiple (comma-separated list): false,
      #   ARI (http-client) related:
      #   - http request type: path,
      #   - param name: channelId,
      #   - endpoint (get): /channels/{channelId}/rtp_statistics
      #
      # Error responses:
      # - 404 - Channel cannot be found.
      def rtpstatistics(channel_id : String) : RTPstat
        response = client.get "/channels/#{channel_id}/rtp_statistics"
      end
    end
  end
end
