# ------------------------------------------------------------------------------
#
#  WARNING !
#
#  This is a generated file. DO NOT EDIT THIS FILE! Your changes will
#  be lost the next time this file is regenerated.
#
#  This file was generated using ctiapps/asterisk crystal shard from the
#  Asterisk PBX version 16.6.0.
#
# ------------------------------------------------------------------------------

module Asterisk
  class ARI
    class Channels < Resources
      # List all active channels in Asterisk.
      def list : HTTP::Client::Response | Array(Channels::Channel)
        format_response ari.get("channels"), Array(Channels::Channel)
      end

      # Create a new channel (originate).
      #
      # Arguments:
      # - `endpoint` - endpoint to call. (required);
      # - `extension` - the extension to dial after the endpoint answers. Mutually exclusive with 'app';
      # - `context` - the context to dial after the endpoint answers. If omitted, uses 'default'. Mutually exclusive with 'app';
      # - `priority` - the priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with 'app';
      # - `label` - the label to dial after the endpoint answers. Will supersede 'priority' if provided. Mutually exclusive with 'app';
      # - `app` - the application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with 'context', 'extension', 'priority', and 'label';
      # - `app_args` - the application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label';
      # - `caller_id` - callerID to use when dialing the endpoint or extension;
      # - `timeout` - timeout (in seconds) before giving up dialing, or -1 for no timeout;
      # - `variables` - the "variables" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { "endpoint": "SIP/Alice", "variables": { "CALLERID(name)": "Alice" } };
      # - `channel_id` - the unique id to assign the channel on creation;
      # - `other_channel_id` - the unique id to assign the second channel when using local channels;
      # - `originator` - the unique id of the channel which is originating this one;
      # - `formats` - the format name capability list to use if originator is not specified. Ex. "ulaw,slin16".  Format names can be found with "core show codecs";
      #
      # Error responses:
      # - 400 - Invalid parameters for originating a channel.
      # - 409 - Channel with given unique ID already exists.
      def originate(endpoint : String, extension : String? = nil, context : String? = nil, priority : Int64? = nil, label : String? = nil, app : String? = nil, app_args : String? = nil, caller_id : String? = nil, timeout : Int32? = 30, variables : Hash(String, String | Bool | Int32 | Float32)? = nil, channel_id : String? = nil, other_channel_id : String? = nil, originator : String? = nil, formats : String? = nil) : HTTP::Client::Response | Channels::Channel
        params = HTTP::Params.encode({"endpoint" => endpoint})

        # Optional parameters
        params += "&" + HTTP::Params.encode({"extension" => extension}) if extension
        params += "&" + HTTP::Params.encode({"context" => context}) if context
        params += "&" + HTTP::Params.encode({"priority" => priority.to_s}) if priority
        params += "&" + HTTP::Params.encode({"label" => label}) if label
        params += "&" + HTTP::Params.encode({"app" => app}) if app
        params += "&" + HTTP::Params.encode({"appArgs" => app_args}) if app_args
        params += "&" + HTTP::Params.encode({"callerId" => caller_id}) if caller_id
        params += "&" + HTTP::Params.encode({"timeout" => timeout.to_s}) if timeout
        params += "&" + HTTP::Params.encode({"channelId" => channel_id}) if channel_id
        params += "&" + HTTP::Params.encode({"otherChannelId" => other_channel_id}) if other_channel_id
        params += "&" + HTTP::Params.encode({"originator" => originator}) if originator
        params += "&" + HTTP::Params.encode({"formats" => formats}) if formats

        request = "channels?" + params
        format_response ari.post(request, body: variables.to_json), Channels::Channel
      end

      # Create channel.
      #
      # Arguments:
      # - `endpoint` - endpoint for channel communication. (required);
      # - `app` - stasis Application to place channel into. (required);
      # - `app_args` - the application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label';
      # - `channel_id` - the unique id to assign the channel on creation;
      # - `other_channel_id` - the unique id to assign the second channel when using local channels;
      # - `originator` - unique ID of the calling channel;
      # - `formats` - the format name capability list to use if originator is not specified. Ex. "ulaw,slin16".  Format names can be found with "core show codecs";
      #
      # Error responses:
      # - 409 - Channel with given unique ID already exists.
      def create(endpoint : String, app : String, app_args : String? = nil, channel_id : String? = nil, other_channel_id : String? = nil, originator : String? = nil, formats : String? = nil) : HTTP::Client::Response | Channels::Channel
        params = HTTP::Params.encode({"endpoint" => endpoint})
        params += "&" + HTTP::Params.encode({"app" => app})

        # Optional parameters
        params += "&" + HTTP::Params.encode({"appArgs" => app_args}) if app_args
        params += "&" + HTTP::Params.encode({"channelId" => channel_id}) if channel_id
        params += "&" + HTTP::Params.encode({"otherChannelId" => other_channel_id}) if other_channel_id
        params += "&" + HTTP::Params.encode({"originator" => originator}) if originator
        params += "&" + HTTP::Params.encode({"formats" => formats}) if formats

        request = "channels/create?" + params
        format_response ari.post(request), Channels::Channel
      end

      # Channel details.
      #
      # Arguments:
      # - `channel_id` - channel's id. (required);
      #
      # Error responses:
      # - 404 - Channel not found
      def get(channel_id : String) : HTTP::Client::Response | Channels::Channel
        format_response ari.get("channels/#{channel_id}"), Channels::Channel
      end

      # Create a new channel (originate with id).
      #
      # Arguments:
      # - `channel_id` - the unique id to assign the channel on creation. (required);
      # - `endpoint` - endpoint to call. (required);
      # - `extension` - the extension to dial after the endpoint answers. Mutually exclusive with 'app';
      # - `context` - the context to dial after the endpoint answers. If omitted, uses 'default'. Mutually exclusive with 'app';
      # - `priority` - the priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with 'app';
      # - `label` - the label to dial after the endpoint answers. Will supersede 'priority' if provided. Mutually exclusive with 'app';
      # - `app` - the application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with 'context', 'extension', 'priority', and 'label';
      # - `app_args` - the application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label';
      # - `caller_id` - callerID to use when dialing the endpoint or extension;
      # - `timeout` - timeout (in seconds) before giving up dialing, or -1 for no timeout;
      # - `variables` - the "variables" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { "endpoint": "SIP/Alice", "variables": { "CALLERID(name)": "Alice" } };
      # - `other_channel_id` - the unique id to assign the second channel when using local channels;
      # - `originator` - the unique id of the channel which is originating this one;
      # - `formats` - the format name capability list to use if originator is not specified. Ex. "ulaw,slin16".  Format names can be found with "core show codecs";
      #
      # Error responses:
      # - 400 - Invalid parameters for originating a channel.
      # - 409 - Channel with given unique ID already exists.
      def originate_with_id(channel_id : String, endpoint : String, extension : String? = nil, context : String? = nil, priority : Int64? = nil, label : String? = nil, app : String? = nil, app_args : String? = nil, caller_id : String? = nil, timeout : Int32? = 30, variables : Hash(String, String | Bool | Int32 | Float32)? = nil, other_channel_id : String? = nil, originator : String? = nil, formats : String? = nil) : HTTP::Client::Response | Channels::Channel
        params = HTTP::Params.encode({"endpoint" => endpoint})

        # Optional parameters
        params += "&" + HTTP::Params.encode({"extension" => extension}) if extension
        params += "&" + HTTP::Params.encode({"context" => context}) if context
        params += "&" + HTTP::Params.encode({"priority" => priority.to_s}) if priority
        params += "&" + HTTP::Params.encode({"label" => label}) if label
        params += "&" + HTTP::Params.encode({"app" => app}) if app
        params += "&" + HTTP::Params.encode({"appArgs" => app_args}) if app_args
        params += "&" + HTTP::Params.encode({"callerId" => caller_id}) if caller_id
        params += "&" + HTTP::Params.encode({"timeout" => timeout.to_s}) if timeout
        params += "&" + HTTP::Params.encode({"otherChannelId" => other_channel_id}) if other_channel_id
        params += "&" + HTTP::Params.encode({"originator" => originator}) if originator
        params += "&" + HTTP::Params.encode({"formats" => formats}) if formats

        request = "channels/#{channel_id}?" + params
        format_response ari.post(request, body: variables.to_json), Channels::Channel
      end

      # Delete (i.e. hangup) a channel.
      #
      # Arguments:
      # - `channel_id` - channel's id. (required);
      # - `reason` - reason for hanging up the channel;
      #
      # Error responses:
      # - 400 - Invalid reason for hangup provided
      # - 404 - Channel not found
      def hangup(channel_id : String, reason : String? = nil)
        # Optional parameters
        params = HTTP::Params.encode({} of String => String)
        params += "&" + HTTP::Params.encode({"reason" => reason}) if reason

        ari.delete "channels/#{channel_id}?" + params
      end

      # Exit application; continue execution in the dialplan.
      #
      # Arguments:
      # - `channel_id` - channel's id. (required);
      # - `context` - the context to continue to;
      # - `extension` - the extension to continue to;
      # - `priority` - the priority to continue to;
      # - `label` - the label to continue to - will supersede 'priority' if both are provided;
      #
      # Error responses:
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      # - 412 - Channel in invalid state
      def continue_in_dialplan(channel_id : String, context : String? = nil, extension : String? = nil, priority : Int32? = nil, label : String? = nil)
        # Optional parameters
        params = HTTP::Params.encode({} of String => String)
        params += "&" + HTTP::Params.encode({"context" => context}) if context
        params += "&" + HTTP::Params.encode({"extension" => extension}) if extension
        params += "&" + HTTP::Params.encode({"priority" => priority.to_s}) if priority
        params += "&" + HTTP::Params.encode({"label" => label}) if label

        ari.post "channels/#{channel_id}/continue?" + params
      end

      # Move the channel from one Stasis application to another.
      #
      # Arguments:
      # - `channel_id` - channel's id. (required);
      # - `app` - the channel will be passed to this Stasis application. (required);
      # - `app_args` - the application arguments to pass to the Stasis application provided by 'app';
      #
      # Error responses:
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      def move(channel_id : String, app : String, app_args : String? = nil)
        params = HTTP::Params.encode({"app" => app})

        # Optional parameters
        params += "&" + HTTP::Params.encode({"appArgs" => app_args}) if app_args

        ari.post "channels/#{channel_id}/move?" + params
      end

      # Redirect the channel to a different location.
      #
      # Arguments:
      # - `channel_id` - channel's id. (required);
      # - `endpoint` - the endpoint to redirect the channel to. (required);
      #
      # Error responses:
      # - 400 - Endpoint parameter not provided
      # - 404 - Channel or endpoint not found
      # - 409 - Channel not in a Stasis application
      # - 422 - Endpoint is not the same type as the channel
      # - 412 - Channel in invalid state
      def redirect(channel_id : String, endpoint : String)
        params = HTTP::Params.encode({"endpoint" => endpoint})
        ari.post "channels/#{channel_id}/redirect?" + params
      end

      # Answer a channel.
      #
      # Arguments:
      # - `channel_id` - channel's id. (required);
      #
      # Error responses:
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      # - 412 - Channel in invalid state
      def answer(channel_id : String)
        ari.post "channels/#{channel_id}/answer"
      end

      # Indicate ringing to a channel.
      #
      # Arguments:
      # - `channel_id` - channel's id. (required);
      #
      # Error responses:
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      # - 412 - Channel in invalid state
      def ring(channel_id : String)
        ari.post "channels/#{channel_id}/ring"
      end

      # Stop ringing indication on a channel if locally generated.
      #
      # Arguments:
      # - `channel_id` - channel's id. (required);
      #
      # Error responses:
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      # - 412 - Channel in invalid state
      def ring_stop(channel_id : String)
        ari.delete "channels/#{channel_id}/ring"
      end

      # Send provided DTMF to a given channel.
      #
      # Arguments:
      # - `channel_id` - channel's id. (required);
      # - `dtmf` - dTMF To send;
      # - `before` - amount of time to wait before DTMF digits (specified in milliseconds) start;
      # - `between` - amount of time in between DTMF digits (specified in milliseconds);
      # - `duration` - length of each DTMF digit (specified in milliseconds);
      # - `after` - amount of time to wait after DTMF digits (specified in milliseconds) end;
      #
      # Error responses:
      # - 400 - DTMF is required
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      # - 412 - Channel in invalid state
      def send_dtmf(channel_id : String, dtmf : String? = nil, before : Int32? = 0, between : Int32? = 100, duration : Int32? = 100, after : Int32? = 0)
        # Optional parameters
        params = HTTP::Params.encode({} of String => String)
        params += "&" + HTTP::Params.encode({"dtmf" => dtmf}) if dtmf
        params += "&" + HTTP::Params.encode({"before" => before.to_s}) if before
        params += "&" + HTTP::Params.encode({"between" => between.to_s}) if between
        params += "&" + HTTP::Params.encode({"duration" => duration.to_s}) if duration
        params += "&" + HTTP::Params.encode({"after" => after.to_s}) if after

        ari.post "channels/#{channel_id}/dtmf?" + params
      end

      # Mute a channel.
      #
      # Arguments:
      # - `channel_id` - channel's id. (required);
      # - `direction` - direction in which to mute audio;
      #
      # Error responses:
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      # - 412 - Channel in invalid state
      def mute(channel_id : String, direction : String? = "both")
        # Optional parameters
        params = HTTP::Params.encode({} of String => String)
        params += "&" + HTTP::Params.encode({"direction" => direction}) if direction

        ari.post "channels/#{channel_id}/mute?" + params
      end

      # Unmute a channel.
      #
      # Arguments:
      # - `channel_id` - channel's id. (required);
      # - `direction` - direction in which to unmute audio;
      #
      # Error responses:
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      # - 412 - Channel in invalid state
      def unmute(channel_id : String, direction : String? = "both")
        # Optional parameters
        params = HTTP::Params.encode({} of String => String)
        params += "&" + HTTP::Params.encode({"direction" => direction}) if direction

        ari.delete "channels/#{channel_id}/mute?" + params
      end

      # Hold a channel.
      #
      # Arguments:
      # - `channel_id` - channel's id. (required);
      #
      # Error responses:
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      # - 412 - Channel in invalid state
      def hold(channel_id : String)
        ari.post "channels/#{channel_id}/hold"
      end

      # Remove a channel from hold.
      #
      # Arguments:
      # - `channel_id` - channel's id. (required);
      #
      # Error responses:
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      # - 412 - Channel in invalid state
      def unhold(channel_id : String)
        ari.delete "channels/#{channel_id}/hold"
      end

      # Play music on hold to a channel.
      #
      # Arguments:
      # - `channel_id` - channel's id. (required);
      # - `moh_class` - music on hold class to use;
      #
      # Error responses:
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      # - 412 - Channel in invalid state
      def start_moh(channel_id : String, moh_class : String? = nil)
        # Optional parameters
        params = HTTP::Params.encode({} of String => String)
        params += "&" + HTTP::Params.encode({"mohClass" => moh_class}) if moh_class

        ari.post "channels/#{channel_id}/moh?" + params
      end

      # Stop playing music on hold to a channel.
      #
      # Arguments:
      # - `channel_id` - channel's id. (required);
      #
      # Error responses:
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      # - 412 - Channel in invalid state
      def stop_moh(channel_id : String)
        ari.delete "channels/#{channel_id}/moh"
      end

      # Play silence to a channel.
      #
      # Arguments:
      # - `channel_id` - channel's id. (required);
      #
      # Error responses:
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      # - 412 - Channel in invalid state
      def start_silence(channel_id : String)
        ari.post "channels/#{channel_id}/silence"
      end

      # Stop playing silence to a channel.
      #
      # Arguments:
      # - `channel_id` - channel's id. (required);
      #
      # Error responses:
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      # - 412 - Channel in invalid state
      def stop_silence(channel_id : String)
        ari.delete "channels/#{channel_id}/silence"
      end

      # Start playback of media.
      #
      # Arguments:
      # - `channel_id` - channel's id. (required);
      # - `media` - media URIs to play. (required). Allow multiple instances (comma-separated list);
      # - `lang` - for sounds, selects language for sound;
      # - `offsetms` - number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified;
      # - `skipms` - number of milliseconds to skip for forward/reverse operations;
      # - `playback_id` - playback ID;
      #
      # Error responses:
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      # - 412 - Channel in invalid state
      def play(channel_id : String, media : String, lang : String? = nil, offsetms : Int32? = nil, skipms : Int32? = 3000, playback_id : String? = nil) : HTTP::Client::Response | Playbacks::Playback
        params = HTTP::Params.encode({"media" => media})

        # Optional parameters
        params += "&" + HTTP::Params.encode({"lang" => lang}) if lang
        params += "&" + HTTP::Params.encode({"offsetms" => offsetms.to_s}) if offsetms
        params += "&" + HTTP::Params.encode({"skipms" => skipms.to_s}) if skipms
        params += "&" + HTTP::Params.encode({"playbackId" => playback_id}) if playback_id

        request = "channels/#{channel_id}/play?" + params
        format_response ari.post(request), Playbacks::Playback
      end

      # Start playback of media and specify the playbackId.
      #
      # Arguments:
      # - `channel_id` - channel's id. (required);
      # - `playback_id` - playback ID. (required);
      # - `media` - media URIs to play. (required). Allow multiple instances (comma-separated list);
      # - `lang` - for sounds, selects language for sound;
      # - `offsetms` - number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified;
      # - `skipms` - number of milliseconds to skip for forward/reverse operations;
      #
      # Error responses:
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      # - 412 - Channel in invalid state
      def play_with_id(channel_id : String, playback_id : String, media : String, lang : String? = nil, offsetms : Int32? = nil, skipms : Int32? = 3000) : HTTP::Client::Response | Playbacks::Playback
        params = HTTP::Params.encode({"media" => media})

        # Optional parameters
        params += "&" + HTTP::Params.encode({"lang" => lang}) if lang
        params += "&" + HTTP::Params.encode({"offsetms" => offsetms.to_s}) if offsetms
        params += "&" + HTTP::Params.encode({"skipms" => skipms.to_s}) if skipms

        request = "channels/#{channel_id}/play/#{playback_id}?" + params
        format_response ari.post(request), Playbacks::Playback
      end

      # Start a recording.
      #
      # Arguments:
      # - `channel_id` - channel's id. (required);
      # - `name` - recording's filename. (required);
      # - `format` - format to encode audio in. (required);
      # - `max_duration_seconds` - maximum duration of the recording, in seconds. 0 for no limit;
      # - `max_silence_seconds` - maximum duration of silence, in seconds. 0 for no limit;
      # - `if_exists` - action to take if a recording with the same name already exists;
      # - `beep` - play beep when recording begins;
      # - `terminate_on` - dTMF input to terminate recording;
      #
      # Error responses:
      # - 400 - Invalid parameters
      # - 404 - Channel not found
      # - 409 - Channel is not in a Stasis application; the channel is currently bridged with other hcannels; A recording with the same name already exists on the system and can not be overwritten because it is in progress or ifExists=fail
      # - 422 - The format specified is unknown on this system
      def record(channel_id : String, name : String, format : String, max_duration_seconds : Int32? = 0, max_silence_seconds : Int32? = 0, if_exists : String? = "fail", beep : Bool? = false, terminate_on : String? = "none") : HTTP::Client::Response | Recordings::LiveRecording
        params = HTTP::Params.encode({"name" => name})
        params += "&" + HTTP::Params.encode({"format" => format})

        # Optional parameters
        params += "&" + HTTP::Params.encode({"maxDurationSeconds" => max_duration_seconds.to_s}) if max_duration_seconds
        params += "&" + HTTP::Params.encode({"maxSilenceSeconds" => max_silence_seconds.to_s}) if max_silence_seconds
        params += "&" + HTTP::Params.encode({"ifExists" => if_exists}) if if_exists
        params += "&" + HTTP::Params.encode({"beep" => beep.to_s}) if beep
        params += "&" + HTTP::Params.encode({"terminateOn" => terminate_on}) if terminate_on

        request = "channels/#{channel_id}/record?" + params
        format_response ari.post(request), Recordings::LiveRecording
      end

      # Get the value of a channel variable or function.
      #
      # Arguments:
      # - `channel_id` - channel's id. (required);
      # - `variable` - the channel variable or function to get. (required);
      #
      # Error responses:
      # - 400 - Missing variable parameter.
      # - 404 - Channel or variable not found
      # - 409 - Channel not in a Stasis application
      def get_channel_var(channel_id : String, variable : String) : HTTP::Client::Response | Asterisk::Variable
        params = HTTP::Params.encode({"variable" => variable})
        request = "channels/#{channel_id}/variable?" + params
        format_response ari.get(request), Asterisk::Variable
      end

      # Set the value of a channel variable or function.
      #
      # Arguments:
      # - `channel_id` - channel's id. (required);
      # - `variable` - the channel variable or function to set. (required);
      # - `value` - the value to set the variable to;
      #
      # Error responses:
      # - 400 - Missing variable parameter.
      # - 404 - Channel not found
      # - 409 - Channel not in a Stasis application
      def set_channel_var(channel_id : String, variable : String, value : String? = nil)
        params = HTTP::Params.encode({"variable" => variable})

        # Optional parameters
        params += "&" + HTTP::Params.encode({"value" => value}) if value

        ari.post "channels/#{channel_id}/variable?" + params
      end

      # Start snooping.
      #
      # Arguments:
      # - `channel_id` - channel's id. (required);
      # - `app` - application the snooping channel is placed into. (required);
      # - `spy` - direction of audio to spy on;
      # - `whisper` - direction of audio to whisper into;
      # - `app_args` - the application arguments to pass to the Stasis application;
      # - `snoop_id` - unique ID to assign to snooping channel;
      #
      # Error responses:
      # - 400 - Invalid parameters
      # - 404 - Channel not found
      def snoop_channel(channel_id : String, app : String, spy : String? = "none", whisper : String? = "none", app_args : String? = nil, snoop_id : String? = nil) : HTTP::Client::Response | Channels::Channel
        params = HTTP::Params.encode({"app" => app})

        # Optional parameters
        params += "&" + HTTP::Params.encode({"spy" => spy}) if spy
        params += "&" + HTTP::Params.encode({"whisper" => whisper}) if whisper
        params += "&" + HTTP::Params.encode({"appArgs" => app_args}) if app_args
        params += "&" + HTTP::Params.encode({"snoopId" => snoop_id}) if snoop_id

        request = "channels/#{channel_id}/snoop?" + params
        format_response ari.post(request), Channels::Channel
      end

      # Start snooping.
      #
      # Arguments:
      # - `channel_id` - channel's id. (required);
      # - `snoop_id` - unique ID to assign to snooping channel. (required);
      # - `app` - application the snooping channel is placed into. (required);
      # - `spy` - direction of audio to spy on;
      # - `whisper` - direction of audio to whisper into;
      # - `app_args` - the application arguments to pass to the Stasis application;
      #
      # Error responses:
      # - 400 - Invalid parameters
      # - 404 - Channel not found
      def snoop_channel_with_id(channel_id : String, snoop_id : String, app : String, spy : String? = "none", whisper : String? = "none", app_args : String? = nil) : HTTP::Client::Response | Channels::Channel
        params = HTTP::Params.encode({"app" => app})

        # Optional parameters
        params += "&" + HTTP::Params.encode({"spy" => spy}) if spy
        params += "&" + HTTP::Params.encode({"whisper" => whisper}) if whisper
        params += "&" + HTTP::Params.encode({"appArgs" => app_args}) if app_args

        request = "channels/#{channel_id}/snoop/#{snoop_id}?" + params
        format_response ari.post(request), Channels::Channel
      end

      # Dial a created channel.
      #
      # Arguments:
      # - `channel_id` - channel's id. (required);
      # - `caller` - channel ID of caller;
      # - `timeout` - dial timeout;
      #
      # Error responses:
      # - 404 - Channel cannot be found.
      # - 409 - Channel cannot be dialed.
      def dial(channel_id : String, caller : String? = nil, timeout : Int32? = 0)
        # Optional parameters
        params = HTTP::Params.encode({} of String => String)
        params += "&" + HTTP::Params.encode({"caller" => caller}) if caller
        params += "&" + HTTP::Params.encode({"timeout" => timeout.to_s}) if timeout

        ari.post "channels/#{channel_id}/dial?" + params
      end

      # RTP stats on a channel.
      #
      # Arguments:
      # - `channel_id` - channel's id. (required);
      #
      # Error responses:
      # - 404 - Channel cannot be found.
      def rtpstatistics(channel_id : String) : HTTP::Client::Response | RTPstat
        format_response ari.get("channels/#{channel_id}/rtp_statistics"), RTPstat
      end

      # Start an External Media session.
      #
      # Arguments:
      # - `app` - stasis Application to place channel into. (required);
      # - `external_host` - hostname/ip:port of external host. (required);
      # - `format` - format to encode audio in. (required);
      # - `channel_id` - the unique id to assign the channel on creation;
      # - `variables` - the "variables" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { "endpoint": "SIP/Alice", "variables": { "CALLERID(name)": "Alice" } };
      # - `encapsulation` - payload encapsulation protocol;
      # - `transport` - transport protocol;
      # - `connection_type` - connection type (client/server);
      # - `direction` - external media direction;
      #
      # Error responses:
      # - 400 - Invalid parameters
      # - 409 - Channel is not in a Stasis application; Channel is already bridged
      def external_media(app : String, external_host : String, format : String, channel_id : String? = nil, variables : Hash(String, String | Bool | Int32 | Float32)? = nil, encapsulation : String? = "rtp", transport : String? = "udp", connection_type : String? = "client", direction : String? = "both") : HTTP::Client::Response | ExternalMedia
        params = HTTP::Params.encode({"app" => app})
        params += "&" + HTTP::Params.encode({"external_host" => external_host})
        params += "&" + HTTP::Params.encode({"format" => format})

        # Optional parameters
        params += "&" + HTTP::Params.encode({"channelId" => channel_id}) if channel_id
        params += "&" + HTTP::Params.encode({"encapsulation" => encapsulation}) if encapsulation
        params += "&" + HTTP::Params.encode({"transport" => transport}) if transport
        params += "&" + HTTP::Params.encode({"connection_type" => connection_type}) if connection_type
        params += "&" + HTTP::Params.encode({"direction" => direction}) if direction

        request = "channels/externalMedia?" + params
        format_response ari.post(request, body: variables.to_json), ExternalMedia
      end
    end
  end
end
